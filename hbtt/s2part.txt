
\itcl{initializing-hypernodes}
`spsubsection.Serializing Data via Hypergraphs`

`p.
The formal Channelized Hypergraph
specification I sketched earlier described both
`q.hypervertices` and `q.hypovertices` as values associated with
hyper- and hyponodes, respectively.  There is no
`i.mandated` relation between hyper- and hypovertex values,
but usually there should be a sensible transformation between them.
In a typical case, hypovertices are used primarily for
serialization, while hypervertices are used for analysis and
processing.  That is, a `CH; graph as a `i.runtime` data
structure will hold most or all values in hypernodes.
When the graph is sent to a different location, the
hypervertex values are split into minimal units
(like individual strings, numbers, or node-proxies),
from which hyponodes are initialized.
When the graph is later `i.deserialized`/, the hypovertices
are then re-aggregated to re-construct the hypervertices,
which in turn initialize their corresponding hypernodes.
`p`

`p.
Figure \ref{lst:initializing-hypernodes} shows an example of code from the
demo where the `CH; graph builder is adding content to a
code-graph, within functions that are used from callbacks triggered by
rule-matches in the parser.  The methods labeled at the top of the
sample (like `OneOverlay;) show the
graph builder creating nodes when provided with values (technically, hypervertices)
allocated elsewhere (they are wrapped in a special kind of pointer
used for values internal to the graph system).  By contrast,
`TwoOverlay; shows similar logic but where the vertex and node
are created together, by the same function.  As this
illustrates, making nodes is a two-step process, where `i.first` the
vertex is allocated, `i.then` the node is likewise, perhaps in a different
code location (these comments apply
both to hypo- and hypervertices and nodes).
`p`


`p.
The freshly created nodes are not yet inserted into a graph; this final
step can occur via code like at `ThreeOverlay;, where new nodes are
joined to prior nodes via a specified hyperedge annotation/classifier,
called a `q.connector` in demo code.  The
demo library uses `Cpp; operators to
modify graph structures, essentially creating a `q.query language` for
graph traversal and manipulation as an embedded `DSL;
(Domain-Specific Language), both adding nodes and
(as at `FourOverlay;) for
moving between nodes based on a desired connector
(modifying the graph structure can also be done with
method-calls, as at `FiveOverlay;).  The main point
for the present context is that nodes serve as wrappers
for ordinary runtime data structures: the `CH; graph
library does not examine or process vertex values
directly.  Instead, it allows applications to traverse
graphs until they find nodes which are of interest for
whatever their present purpose, and allows the
application to use the node's initialized value
however it sees fit (unpacking the vertex as an ordinary
`Cpp; pointer).
`p`
%`vspace<1em>;

`p.
This illustrates one contrast between `CH; and `RDF;: `CH; graphs can
be used in a way that fully decouples graph `i.structure` from
any notion of value-manipulation or semantics.  The demo
libraries, for instance, recognize only structural relations
between values; they do not have any means to
`q.look inside` or use values.  As sampled in \ref{lst:dominion-types},
each graph has a `q.dominion` which encompasses a set of types
that may be used as vertex values.  The demo Hypergraph library
assumes that all node-values belong to types identified at
compile-time, and on that basis enforces
some measure of compile-time type checking.
`p`
%`itcl<initializing-hypernodes>;

%\vsftcl{h}{dominion-types}

%`vspace<1em>;
`p.
The node classes are equipped
with constructors that accept vertex pointers from
`q.dominion` types,
and have methods to extract pointers of those types (the actual
implementation of these functions is centered at `OneOverlay; in
\ref{lst:dominion},
which is macro code that gets included while the node classes are
being compiled %-- in general, the list of types asserted
in `typesH; generates several different kinds of code
depending on which preprocessor macros are defined at the
point where the `typesH; file is included).  Overall,
the node classes hold values (vertices) but do not
operate on then; each vertex is opaque to the `CH; graph
engine, stored within a node for subsequent use elsewhere in the
application, but only actually used at the application level.
`p`

\itcl{dominion-types}
\itcl{dominion}
`p.
This manner of separating content from structure is conceptually
and operationally different from `RDF;: `RDF;
structures capture relations on multiple scales at once
%-- which also means that `RDF; graphs are suitable for
both serialization and analysis.  By contrast, `CH; graphs %-- or at
least those constructed via code sampled here %-- are not
directly serializable, because each node holds a value that is,
in its underlying form, a `Cpp; pointer.  Serializing the
overall graph depends on serializing each vertex, which in turn
depends on algorithms varying based on vertex types.  Note that
`q.serializing vertices` makes no sense in the `RDF; context, because
`RDF; nodes by definition are either atomic literals or `URL;s
pointing at web resources.  Nodes in `CH;, in contrast to `RDF;,
have `q.values` which can be multi-part aggregates of any type
(whereas `RDF; literals are constrained to a handful of basic types like
numbers and character strings).
`p`

`p.
On the other hand,
`CH; graphs can be `i.transformed` into serializable
structures by mapping hypervertices onto sets of hypovertices,
thereby appointing hypernodes with an array of hyponodes.
Enforcing constraints related to
linearity, types, and product-type transforms can result in `CH;s whose hypernodes
exhibit the same structural properties as a program's runtime memory.
It is helpful to think of hypernodes as analogous to either `CStruct;s or
`CArray;s.  Varying the precise requirements on hypernodes allows
`CH;s to mimic the memory conventions of different programming languages
(for example, prohibiting non-identical but overlapping hypernodes
mimics a language without pointer arithmetic, which as such has no mechanism
for creating a reference to a proper subset of the memory area allocated
for a typed value).  These specifications help ensure that
serialization algorithms are straightforward to design: for
example, code that serializes hypervertex types to binary buffers
(like `QDataStream;) can with little change be adopted to map
hypernodes to hyponodes.  As such, `CH; graphs can be used
via processing `i.hypervertices` as runtime data structures, and used
via processing `i.hypovertices` for data sharing and network transfers:
the hyponodes become a kind of `q.transport` layer whose main
role lies in moving graphs from place to place.
`p`

`p.
The fact that `CH; allows a stricter separation of `i.structure` and
`i.content` also has ramifications for semantics and analytic
capabilities, compared to `RDF;, which I will discuss next.
`p`

