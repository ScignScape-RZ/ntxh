
`p.
In particular, to take an example especially relevant for this volume,
the code which directly interacts with `USH; devices needs particularly
thorough documentation, review, and (perhaps, as a way to
achieve these) annotations.  Code designed and annotated via
techniques reviewed in this chapter will not be guaranteed to
protect privacy, block malware, or detect all device-related errors.
But such code `i.will` be amenable to analytic processes which
should increase different parties' (doctors, patients,
application developers) assessment of its transparency and
trustworthiness.  In the end, components earn trust not through
one monolithic show of robustness but via designs judged
to reflect quality according to multiple standards and
paradigms, with each approach to code evaluation adding its
own measure to stakeholders' overall trust in the system.
`p`

However, in the general case, strong typing alone does not provide strong 
enough guarantees for fragile code.  

`p.
A fundamental aspect of programming is asserting specifications on when
bodies of code should be executed %-- criteria which can be coarse-grained
(like requiring that numbers passed to a function must be
integers), or finer (like stipulating that a number must lie in a fixed
range, or that two lists of numbers must have the same size).  Logically
separating code which `i.makes` assumptions %-- in the course
of performing operations (which may have concrete, even physical
effects, as in CyberPhysical Systems) %-- from code which
`i.checks` assumptions (to ensure that effectual code is not improperly
called), simplifies the design and maintenance of both
kinds of code %-- which I'll call `q.fragile` and `q.gatekeeper`/.
Fragile code is code which can fail (for instance, throw an
exception or cause a software crash) when used improperly.  The canonical
example of fragile code is a function which can fail when called with the wrong
sort of arguments %-- arguments that have the correct `i.type` but are not
in the proper range, or use incorrect scales of measurements,
or do not obey expected inter-argument relationships.
Gatekeeper code is then code which examines the arguments intended
for fragile functions, preventing the fragile code from executing
when it might be unsafe or improper to do so.
`p`

`p.
While stretches of code may informally be identified as
`q.fragile` or `q.gatekeeper`/, it is a good idea to make this
distinction explicit and deliberate, as a design pattern.
Distinguishing gatekeeper and fragile code is a good example of
`q.separation of concerns`/: the maxim that
code serving different purposes should
be logically separated.  Gatekeeper and fragile code
have distinct roles, and tend to involve different programming
techniques.  Both kinds of code therefore tend to be clearer
and easier to maintain insofar as they are logically separated.
`p`

`p.
To demonstrate the real-world importance of properly planning and
co-ordinating fragile and gatekeeper code, consider the
model of `q.Ubiquitous Computing` pertinent to the
book series to which this volume (and hence
this chapter) belongs.  As explained in the
series introduction,
the preeminent `q.Ubiquitous Sensing for Healthcare` (`USH;) principles
include `q.transparency` (openness about how `USH; systems are designed
and operationalized) and `q.trustworthiness` (demonstrably secure
engineering, particularly in the context of personal privacy and
protecting access to personal medical data).`footnote.
`url<https://sites.google.com/view/series-title-ausah/home?authuser=0>;
`footnote`  Data in the `USH;
context is generated by physical biomedical devices, and the
shape and properties of this data %-- including details such as
its numeric dimensions, scales of measurement, and possible range
for component values %-- are closely tied to the scientific purpose
and manufacturing of particular devices.
`p`


 %-- perhaps OpenCog and its `q.Atom Space` system, and
certainly the `CH; model highlighted in this chapter %-- 


  For example, safety certification can proceed
by documenting the assumptions that each safety-critical function
implementation makes and then that those assumptions are reasonable
given how each function are called.
Such an `q.assume-and-justify` two-step
is easier when assumptions are modeled via structures intrinsic to the
type system.  
`footnote.
Doing so allows preconditions to be
encoded directly in the type system, making it possible to restrict the
diversity of values which a function may receive and thereby allow
the implementation to make assumptions which would be unwarranted
otherwise.  




`p.
In material fact, computers work with `q.numbers` that
are electrical signals; but in practice, we reason about
software via computer code which abstracts and is
materially removed from actual running programs.  In these
terms, we can note that `q.computers` (in this
somewhat abstract sense) do not deal `i.directly` with
numbers (or indeed other kinds of values), but rather
deal with `q.symbols` that express, or serve as placeholders
for, or `q.carry` values.  Even `q.literal` values are composed
of symbols: the number (say) `oneTwoThree;, which has a particular
physical incarnation in electrons, is represented in source
code by a Unicode or `ascii; character string (which materially
bears little resemblance to a `q.digital` `oneTwoThree;).
`p`


`p.
Because `q.unitialized` carriers and `q.dangling pointers`
are coding errors, within `q.correct` code, carriers
and values are bound tightly enough that the whole carrier/value
distinction might be considered an artifact of programming practice,
out of place in a rigorous discussion of programming languages
(as logicomathematical systems, in some sense).  But even
if the `q.career` of symbols is unremarkable, we cannot avoid
in some contexts %-- within a debugger and/or an `IDE;
(Integrated Development Environment, software for writing programs),
for example %-- needing to formally distinguish the carrier
from the value which it holds, or recognize that carriers
can potentially be in a `q.state` where, at some point in which
they are relevant for code analysis or evaluation, they
do not yet (or do not any longer) hold meaningful values.
The `q.trajectory` of carrier `q.lifetime` %-- from being declared,
to being initialized, to falling `q.out of scope` or otherwise `q.retired`
%-- should be integrated into our formal inventory of programming
constructs, not relegated to an informal `q.metalanguage` suitable
for discussing computer code as practical documents but not as formal systems.
I'd make the analogy to how lambda calculus models `q.symbol rewriting`
as a formal part of its theory, rather than a notational intuition
which reflects mathematical conventions but is seen as part
of mathematical `q.metalanguage` rather than mathematical `q.language`/.
The history of mathematical foundations reveals how convention, notation,
and metalanguage tends to become codified into theory, models, and
(mathematical) language proper.  Likewise, we can develop a formal
theory of carriers which models that carriers have different states
%-- including ones where they do not hold meaningful values
%-- separate and apart from whether the underlying type
system allows for mutable value-holders, or pointers, references
to lexically scoped symbols, and other code formations that
can lead to `q.undefined behavior`/.
`p`

`p.
Consider a carrier which has been declared, so it is assigned a type and belongs to
some given scope in its source code, but has not yet been initialized.
The carrier does not therefore, in the theory, hold any value at all.  This
is different from holding a default value, or a null value, or
any other value that a type system might introduce to represent
`q.missing` information.  In practice, of course, insofar as a `q.carrier` refers
to a segment of memory, the carrier will be seen by the computer as having
`q.some` (effectively random) value; some bit pattern left behind by some
other calculation, which obviously has no `q.meaning`/.  Programming languages
usually talk about the (mis)use of uninitialized variables (i.e., in this
context, carriers) as leading to `q.undefined behavior` and therefore beyond any
structured reasoning about code, and leave it at that.  We can be more rigorous
however and define being uninitialized as a `i.state` of a carrier, as is
holding a meaningful value (once it `i.is` initialized) and then, some time
later, no longer holding a meaningful value, because its associated memory
has been deemed recyclable (typically, once a symbol falls out of scope).  Any
carrier therefore has at least three kinds of state, which we can
call `i.pre-initialized`/, `i.initialized`/, and `i.retired`/.`footnote.
Again, though,
we should not think of (say) `q.Preinitialized` as a `i.value` with a `i.type`/.
A carrier declared as type `intthrtwo;, say (32-bit integer) can only hold
values of this type, when it holds any value at all, which precludes
interpreting `q.Preinitialized` as some kind of `q.null` value which is somehow
arranged to be an instance of `intthrtwo;.
`footnote`
`p`


