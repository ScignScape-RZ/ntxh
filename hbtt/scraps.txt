
`p.
In particular, to take an example especially relevant for this volume,
the code which directly interacts with `USH; devices needs particularly
thorough documentation, review, and (perhaps, as a way to
achieve these) annotations.  Code designed and annotated via
techniques reviewed in this chapter will not be guaranteed to
protect privacy, block malware, or detect all device-related errors.
But such code `i.will` be amenable to analytic processes which
should increase different parties' (doctors, patients,
application developers) assessment of its transparency and
trustworthiness.  In the end, components earn trust not through
one monolithic show of robustness but via designs judged
to reflect quality according to multiple standards and
paradigms, with each approach to code evaluation adding its
own measure to stakeholders' overall trust in the system.
`p`

However, in the general case, strong typing alone does not provide strong 
enough guarantees for fragile code.  

`p.
A fundamental aspect of programming is asserting specifications on when
bodies of code should be executed %-- criteria which can be coarse-grained
(like requiring that numbers passed to a function must be
integers), or finer (like stipulating that a number must lie in a fixed
range, or that two lists of numbers must have the same size).  Logically
separating code which `i.makes` assumptions %-- in the course
of performing operations (which may have concrete, even physical
effects, as in CyberPhysical Systems) %-- from code which
`i.checks` assumptions (to ensure that effectual code is not improperly
called), simplifies the design and maintenance of both
kinds of code %-- which I'll call `q.fragile` and `q.gatekeeper`/.
Fragile code is code which can fail (for instance, throw an
exception or cause a software crash) when used improperly.  The canonical
example of fragile code is a function which can fail when called with the wrong
sort of arguments %-- arguments that have the correct `i.type` but are not
in the proper range, or use incorrect scales of measurements,
or do not obey expected inter-argument relationships.
Gatekeeper code is then code which examines the arguments intended
for fragile functions, preventing the fragile code from executing
when it might be unsafe or improper to do so.
`p`

`p.
While stretches of code may informally be identified as
`q.fragile` or `q.gatekeeper`/, it is a good idea to make this
distinction explicit and deliberate, as a design pattern.
Distinguishing gatekeeper and fragile code is a good example of
`q.separation of concerns`/: the maxim that
code serving different purposes should
be logically separated.  Gatekeeper and fragile code
have distinct roles, and tend to involve different programming
techniques.  Both kinds of code therefore tend to be clearer
and easier to maintain insofar as they are logically separated.
`p`

`p.
To demonstrate the real-world importance of properly planning and
co-ordinating fragile and gatekeeper code, consider the
model of `q.Ubiquitous Computing` pertinent to the
book series to which this volume (and hence
this chapter) belongs.  As explained in the
series introduction,
the preeminent `q.Ubiquitous Sensing for Healthcare` (`USH;) principles
include `q.transparency` (openness about how `USH; systems are designed
and operationalized) and `q.trustworthiness` (demonstrably secure
engineering, particularly in the context of personal privacy and
protecting access to personal medical data).`footnote.
`url<https://sites.google.com/view/series-title-ausah/home?authuser=0>;
`footnote`  Data in the `USH;
context is generated by physical biomedical devices, and the
shape and properties of this data %-- including details such as
its numeric dimensions, scales of measurement, and possible range
for component values %-- are closely tied to the scientific purpose
and manufacturing of particular devices.
`p`


 %-- perhaps OpenCog and its `q.Atom Space` system, and
certainly the `CH; model highlighted in this chapter %-- 

