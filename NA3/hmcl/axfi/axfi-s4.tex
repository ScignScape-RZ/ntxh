
\section{Extending AXFI}

\p{In some contexts, \AXFI{} can be used as an 
alternative format for serializing data conformant 
to other standards related to image annotation.  
When these use-cases call for refining the 
\AXFI{} specifications, the architecture of 
\AXFI{} Object Libraries and \GTagML{} can be 
employed to make these extensions compatible 
with the core \AXFI{} model, and to 
facilitate application integration.  This 
section will consider several extensions 
along these lines so that \AXFI{} can 
be used as an alternative to \GatingML{} 
(in the Flow Cytometry context) and 
to \DICOMSR{} or \AIM{} (in the biomedical 
imaging context).}

\p{Given any \AXFI{} which sustains the design 
principles of \AXFI{} itself, the extension's 
central technology should be an \AXFI{} Object Library 
which includes object classes modeling the relevant 
extended semantics as well as the primary, 
geometric-based \AXFI{} data.  It is recommended 
that the Object Library be implemented in a programming 
language and environment which minimizes external 
dependencies.  In particular, \C{} or \Cpp{} are 
preferred to scripting languages unless the 
library can be developed in \q{pure} code of 
those languages, without importing packages 
or modules which are mostly composed in 
\C{}/\Cpp{}.  For \Cpp{} libraries, it is recommended 
that most dependencies be limited to a single 
overarching framework, like \textbf{boost} or 
\Qt{}, without \textit{mixing} dependencies.  
In \Qt{}, for instance, the \IO{}, Regular Expression, 
and \XML{} support (and so on) is sufficiently mature 
and full-featured that there should be no need for 
dependencies on \textbf{boost::filesystem}, 
\textbf{Boost.Regex}, or etc.}

\p{For sake of discussion --- and to remain 
consistent with the default \DSPIN{} implementation 
--- assume therefore that prototypical 
\AXFI{} Object Libraries are implemented 
in \Qt{}-based \Cpp{} code.  The core of any 
new (potentially extended) library, then, 
is a \textit{co-serialization interface} 
which includes procedures for serializing 
and deserializing data structures 
(including \Cpp{} class instances assuming 
certain template procedures are instantiated 
for those classes), as well as \q{querying} 
encoded data as part of the deserialization 
process.  For \DSPIN{}, the co-serialization 
logic is implemented using LTS's \ConceptsDB{}, 
a hypergraph database engine.  An overview 
of this technology is outside the scope of 
\AXFI{}, but the key detail is that 
\ConceptsDB{} allows data structures to be 
modeled and then encoded via certain hypergraph 
constructions, and that the resulting hypergraph 
models are manipulated via an interface which 
incorporates Functional Programming techniques 
(more so than conventional Object-Oriented 
styles).  An \AXFI{} Object Library mimicking 
\DSPIN{}, accordingly, would implement 
logic to serialize and deserialize \AXFI{} objects 
according to this hypergraph-based interface.}

\p{Such an Object Library would then have, at 
its core, a suite of annotation objects 
(plus objects expressing an extended semantics) 
and would have procedures for serializing and 
deserializing these objects as hypergraph data 
structures.  This co-serialization interface 
would then be augmented to support \GTagML{} by 
re-implementing the serialization and 
deserialization procedures to generate/parse 
\GTagML{} instead of the native \ConceptsDB{} 
hypergraph format.  The \GTagML{} interface 
should be tested to confirm that it 
functions equivalently to that of \ConceptsDB{}.  
Once that is verified, the generated \GTagML{} 
code can be provisioned with \q{grounding} 
metadata, that is, with parameters indicating 
the relation of the serialization content to 
the data types and procedures of the Object 
Library.  In the simplest case, a 
\GTagML{} node is \q{grounded} by being 
marked as encoding one instance of an 
object class.}

\p{An important aspect of an \AXFI{} Object 
Library, then, is functional equivalence 
between the \ConceptsDB{} serialization 
and the \GTagML{} serialization.  This notion 
of functional equivalence may then be 
extended when the purpose of an Object 
Library is to incorporate features from 
other data standards, or to allow \AXFI{} 
to replace other data formats.  For 
example, Object Libraries designed 
to adopt \AXFI{} in lieu of \GatingML{}, 
\AIM{}, or \DICOMSR{}, respectively, 
would need to demonstrate that 
they serialize and deserialize structures 
in a manner functionally equivalent to 
the formats being emulated.}

\p{In these scenarios, Object Libraries 
need to orient themselves not only to standards 
for existing markup formats, but also to 
existing libraries where data in such formats 
is generated and consumed.  For example, 
the de facto reference implementation for 
reading \GatingML{} data appears to be the 
\R{}/Bioconductor package \textbf{flowUtils}.  
Likewise, the \AIM{} data format was initially engineered 
via an open-source \Cpp{} library 

 }

\p{}

\p{}

\p{}

