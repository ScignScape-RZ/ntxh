\p{It is possible to study CyberPhysical systems at the level 
of individual devices.  Each device has its own mechanical 
properties, generates its own kind of data, and may 
require its own software to interpret 
and understand that data.  As 
devices proliferate, so does the diversity of 
software via which users may access whatever 
data they generate.
}
\p{CyberPhysical systems may also be seen in a more holistic way.  
As CyberPhysical networks proliferate, we can envision a 
rise in technologies that merge and integrate data from 
many kinds of devices and many different vendors.  
Such an eventuality has already been contemplated, including 
in this volume.  Teixera \i{et. al.}, for example, 
argue that 
\begin{dquote}Overall, the increase in sensors, devices, and appliances, in our homes, has transformed it into a rather complex environment with which to interact. This characteristic cannot be merely addressed by a matching set of device-dependent applications, turning the smart home into a set of isolated interactive artifacts. Hence, there is a strong need to unify this experience, blending this diversity into a unique interactive ecosystem. This can be tackled, to a large extent by the proposal of a unique, integrated, ubiquitous distributed smart home application capable of handling a dynamic set of sensors and devices and providing the different house occupants (e.g., children, teenagers, young adults, and elderly) with natural and simple ways of controlling and accessing information. However, the creation of such application presents a challenge, particularly due to the need to support natural and adaptive forms of interaction beyond a simple home dashboard application.
\end{dquote}
I will use the term \i{hub application} to describe software 
meeting the requirements of what Teixera \i{et. al.} call an 
\q{application capable of handling a dynamic set of 
sensors and devices}. 
}
\p{Hub applications must receive data from 
many kinds of devices.  They must also respond properly to 
data once it is received.  Each kind of device  
should have a corresponding software component 
built around data generated by \i{that particular} 
device.  For sake of discussion, I will call such 
device-specific software components a \i{hub library}.  
Hub libraries need to bridge the low-level 
realm of CyberPhysical signals (and the networks that carry them) 
with the high-level realm of software engineering: \GUI{} 
components, data validation, fluid and responsive User Experience, 
and so forth. 
We may assume that hub applications will feature many 
hub libraries, and that implementing hub libraries will 
become an integral step in the process of deploying 
CyberPhysical instruments.  
}
\p{Hub applications, in short, serve as central loci organizing 
collections of hub libraries.  In this role they have a significance 
beyond just supplying a User Interface to CyberPhysical data.  
Hub libraries would provide a 
concrete artifact that engineers may consult to obtain information 
about device properties and expected behavior.  
Compared to (as Teixera \i{et. al.} put it) 
\q{a set of isolated interactive artifacts}, I believe 
hub applications and hub libraries, with a centralized 
architecture, are more conducive to rigorous, concrete representation of CyberPhysical 
devices as technical products.  This rigor can  
make CyberPhysical systems more secure and trustworthy \mdash{} 
hub applications may be used for testing and prototyping devices and
their supporting code, even before they are brought to market.            
}
\p{This chapter is not explicitly about hub applications; 
here I will examine coding and code documentation techniques 
which are applicable in many contexts.  However, CyberPhysical 
hubs are a good case study in programming contexts where   
Requirements Engineering is an intrinsic architectural feature.  
I write this 
chapter, then, from the perspective of a programmer 
creating a hub library for some form of 
CyberPhysical input.  This programmer needs to express in 
code the physical and computational details specific 
to the device's signals, functionality, and 
capabilities.  The hub library should serve 
as a reference point, a proxy for the device itself, 
in that engineers may study the library as an indirect 
way of coming to understand the device.  Given 
these requirements, hub libraries need an especially 
rigorous development methodology, one that emphasizes 
strict documentation and verification of coding requirements.    
} 
\p{I claim, also, that hub libraries are operationally similar 
to a different genre of software components: code libraries 
providing access to scientific 
data sets.  In practice, most CyberPhysical devices are 
products of Research and Development cycles that emanate 
from scientific and technological advances.  Research 
data generated during an \RnD{} phase may therefore be 
an originating source for data models which ultimately govern 
the deployed CyberPhysical software.  As a result, code 
libraries which systematically access research data 
may be seen as ancestral versions of hub libraries 
\mdash{} even though hub 
libraries prototypically work with real-time input, 
whereas data sets are curated information spaces that are 
frozen in time, and potentially reused in multiple 
research projects.    
}
\p{In essence, libraries for accessing research data sets 
\mdash{} belonging to what may be called \q{dataset applications} \mdash{} 
are analogous to hub libraries whose  
real-time networking logic is subtracted out; 
their input data comes from static files, not 
from any kind of decentralized or wireless networks.  
Hub libraries actually have two roles: they are low-level 
drivers attuned to network signals, and also high-level 
processors transforming raw data into analyzable and 
visualizable representations.  Hub libraries can 
inherit the logic for this second, high-level role from \RnD{} 
data-set libraries.  This means that published data sets, 
and their accompanying code, are an important foundation 
for establishing data models and coding practices that may 
propagate through CyberPhysical systems' subsequent  
deployment phases.          
}
\p{So, although I claimed to write this chapter from the perspective 
of a programming writing a hub library, it is more literally 
accurate to say that I am writing from the perspective 
of a programmer composing dataset applications \mdash{} because 
that \i{is} my perspective in real life.  I contend that 
dataset applications are a reasonable proxy for  
hub libraries, so that these perspectives will coincide 
for many practical purposes.
}
\p{I will orient this chapter's discussion toward 
the \Cpp{} programming language, which is arguably the most
central point from which to consider the integration 
of concerns \mdash{} \GUI{}, device networking, analytics 
\mdash{} characteristic of CyberPhysical hub software.  
\Cpp{} is unique in having extensive resources 
traversing various programming domains, like 
native \GUI{} components alongside low-level networking 
and logically rigorous data verification.  For 
this reason \Cpp{} is a reasonable default language 
for examining how these various concerns interoperate.
}
\p{The (predominantly \Cpp{}) demo code for this chapter  
includes several re-published 
data sets in various technical and CyberPhysical domains 
(bioacoustics, speech samples, and parsed language samples) 
together with \q{dataset applications} to access research 
data and model its properties.  I hope these demonstrations 
serve to illustrate how future CyberPhysical data sets might 
be organized.  I have also supplemented the data sets with 
code bases operationalizing many of the theoretical 
paradigms I present in the second half of this chapter.  
For example, the code provides a modest but demonstrative 
scripting platform via a hypergraph-based Intermediate 
Representation based on (what I call) Channel Algebra.  
A few code samples are drawn from the demo and 
published here to illustrate 
some basic patterns in these hypergraph structures; 
interested readers may find that work discussed in much 
greater detail in the documentation for the demo code.     
}
\p{The first two sections in this chapter, however, are 
less theoretical and less code-oriented.  These sections discuss 
hub applications and CyberPhysical systems on a more practical 
level: what are representative examples of  
data structures and coding requirements that hub 
libraries will need to encapsulate?  I will 
then, in the final several sections, turn to 
computer code at a more theoretical level, outlining 
certain representational paradigms, such as 
Directed Hypergraphs, which I believe can yield more 
expressive and comprehensive models of coding structures 
and requirements.  
}
