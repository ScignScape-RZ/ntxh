
\documentclass[11pt,twocolumn]{article}

`include<commands>;


`document,
`title.Hypergraph Type Theory for Specifications-Conformant Code and Generalized Lambda Calculus: A Case 
Study in Security Protocols for Biomedical Devices`
`author.Nathaniel Christen`


\twocolumn[\begin{@twocolumnfalse}
`maketitle;

`abstract,
This chapter will explore the integration of several methodologies 
related to source code analysis and software Requirements 
Engineering.  The purpose of this 
integration is, first, to develop a systematic (albeit not 
rigorously mathematical) account of foundational programming 
elements such as functions/procedures, function calls, and 
inter-procedure information flows.  On that basis, 
secondly, data models can be formalized which 

 Several case studies (briefly outlined 
in the text, and demonstrated in greater detail in 
conjunction with accompanying data sets) illustrate 
documentation and programming techniques for real-world 
data samples.  One focus of the demos concerns 
code examples implementing security protocols 


 In particular, I will review Semantic Web 
and general graph-based representations of source code, 
alongside applied type theory (for expressing 
programming languages' type systems).  
The principal relatively new 
representational device I suggest here involves a theory 
of `q.channels` which ties together models associated with 
lambda calculi, type theory, and graph-based code representation.  
I argue that the perspective afforded by channels permits 
succinct protocols for describing procedural 
semantics/types and holistic program behavior.  I 
outline how the proposed techniques support documentation and 
verification of procedural, data type, and holistic 
specifications %-- implementational assumptions on procedures  
and/or modeling assumptions on types.   
We need new methodologies for indicating and testing 
programming assumptions/specifications, I believe, insofar as 
there are several choices for handling requirements in 
a software context, each with their own trade-offs.  
Requirements Engineering protocols should therefore 
be developed within the foundational planning and 
prototyping stages of a project, particularly
in CyberPhysical contexts which tend to exhibit both 
empirically-driven data types (with granular 
modeling parameters) and strong robustness/safety mandates.
For more in-depth 
examples, an accompanying open-source data set (at
\url{https://github.com/scignscape/ntxh}) 
demonstrates code libraries, 
as well as data set architectures and 
security protocols, concretizing 
techniques outlined here.
`abstract` 

%\newsavebox{\qboxi}
\newsavebox{\qboxii}

%\begin{lrbox}{\qboxi}
%`frquote,
%\\ \longdash{} Jean Petitot, \cite[p. 1]{PetitotSyntaxe}
%`frquote`
%\end{lrbox}	

\begin{lrbox}{\qboxii}
`frquote,
Some seek to encourage reductions in consumption of energy
and  material  goods,  or  to  support  changes  in  purchasing
behavior.  Others  seek  to  use  software  capabilities  to  build
smarter (lower impact) infrastructure. However, there is a lack
of  common  understanding  of  the  fundamental  concepts  of
sustainability and how they apply, and a need for a common
ground and consistent terminology. As such, persistent 
misperceptions occur, as researchers and practitioners disagree over
whether we're even asking the right questions ...
We  lack  a  coherent  framework  with  sound  theoretical  basis
that can provide a well-understood trans-disciplinary basis for
sustainability design. --- \textit{The Karlskrona Manifesto} {\cite[p. 5]{Karlskrona}}
`frquote`
\end{lrbox}	

\vspace{1em}
`flushright,
%\usebox{\qboxi}
\usebox{\qboxii}
`flushright`
\vspace{1em}

`decoline;
`vspace<3em>;
\end{@twocolumnfalse}]

\addcontentsline{toc}{section}{Hypergraph-Based Type Theory ...}


`input<intro.ngml>;

`input<section1.ngml>;

`input<section2.ngml>;

`input<section3.ngml>;
`input<section3a.ngml>;
`input<section3b.ngml>;

`input<section4.ngml>;
`input<section4a.ngml>;
`input<section4b.ngml>;

%`input<section4.ngml>;

`input<conclusion.ngml>;

`input<biblio>;

`document`
