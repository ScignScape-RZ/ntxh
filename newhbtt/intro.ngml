
`p.
It is possible to look at CyberPhysical systems at the level 
of individual devices.  Each device has its own mechanical 
properties, generates its own kind of data, and 
requires specially designed software to interpret 
and understand that data.  Often users view the 
data generated by CyberPhysical devices on phone 
`q.apps` or specialized touch-screens.  As 
devices proliferate, so does the diversity of 
software which users use to access device data.
`p`

`p.
CyberPhysical systems can also be seen in a more holistic way.  
As CyberPhysical networks proliferate, we can envision a 
rise in technologies that merge and integrate data from 
many kinds of devices, from many different vendors.  
This eventuality has already been contemplated, including 
in this volume.  Teixera `i.et. al.`/, for example, 
argue that 

`dquote,
Overall, the increase in sensors, devices, and appliances, in our homes, has transformed it into a rather complex environment with which to interact. This characteristic cannot be merely addressed by a matching set of device-dependent applications, turning the smart home into a set of isolated interactive artifacts. Hence, there is a strong need to unify this experience, blending this diversity into a unique interactive ecosystem. This can be tackled, to a large extent by the proposal of a unique, integrated, ubiquitous distributed smart home application capable of handling a dynamic set of sensors and devices and providing the different house occupants (e.g., children, teenagers, young adults, and elderly) with natural and simple ways of controlling and accessing information. However, the creation of such application presents a challenge, particularly due to the need to support natural and adaptive forms of interaction beyond a simple home dashboard application.
`dquote`

I will use the term `i.hub application` to describe software 
meeting the requirements of what Teixera `i.et. al.` call an 
`q.application capable of handling a dynamic set of 
sensors and devices`/. 
`p`

`p.
Hub applications must receive data from 
many kinds of devices.  They must also respond properly to 
data once it is received.  For each kind of device, 
there must then be a corresponding software component,  
part of the hub application, which is specifically 
capable of understanding data generated by `i.that particular` 
device.  For sake of discussion, I will call such 
device-specific software components a `i.hub library`/.  
We may assume that hub applications will feature many 
hub libraries, and that implementing hub libraries will 
become an integral step in the process of deploying 
CyberPhysical instruments.  
Hub libraries need to bridge the low-level 
realm of CyberPhysical signals (and the networks that carry them) 
with the high-level realm of software engineering: `GUI; 
components, data validation, fluid and responsive User Experience, 
and so forth. 
`p`

`p.
Hub applications, in short, serve as central loci organizing 
collections of hub libraries.  In this role they have a significance 
beyond just supplying a User Interface to CyberPhysical data.  
Hub libraries would need to manifest `i.data models`  
conveying technical details about devices; for instance, scientific 
and mathematical details about the proper range and dimensions 
of data fields.  Hub libraries would provide a 
concrete artifact that engineers could consult to obtain information 
about device properties, data models, and expected behavior.  
Compared to `q.a set of isolated interactive artifacts`/, I believe 
the centralized architecture of hub applications and hub libraries 
is more conducive to rigorous, concrete representation of CyberPhysical 
devices as technical products.  This centralized focus can  
make CyberPhysical systems more secure and trustworthy %-- 
hub applications can be used for testing and protyping devices and 
their supporting code, even before devices are brought to market.            
`p`

`p.
This chapter is not explicitly about hub applications; 
here I will examine coding and code documentation techniques 
which are applicable in many contexts.  However, CyberPhysical 
hubs are a good case study in programming contexts where   
Requirements Engineering is an intrinsic architectural feature.  
I write this 
chapter, then, from the perspective of a programmer 
creating a `q.hub library` for some form of 
CyberPhysical input.  This programmer needs to express in 
code the physical and computational details specific 
to the device's signals; its functionality and 
capabilities.  The hub library should serve 
as a reference point, a proxy for the device itself, 
in that engineers may study the library as an indirect 
way of coming to understand the device.  Given 
these requirements, hub libraries need an especially 
rigorous development methodology, one that emphasizes 
strict documentation and verification of coding requirements.    
`p` 

`p.
The first two sections in this chapter will discuss hub 
applications and CyberPhysical systems on a more practical 
level: what are representative examples of the 
data structures and coding requirements that hub 
libraries will need to encapsulate?  I will 
then, in the final two sections, turn to 
computer code at a more theoretical level, outlining 
certain representational paradigms, such as 
Directed Hypergraphs, which I believe can yield more 
expressive and comprehensive models of coding structures 
and requirements.  
`p`

