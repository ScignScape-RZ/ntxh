\p{It is possible to study CyberPhysical systems at the level 
of individual devices.  Each device has its own mechanical 
properties, generates its own kind of data, and 
requires specially designed software to interpret 
and understand that data.  Often users view the 
data generated by CyberPhysical devices on phone 
\q{apps} or specialized touch-screens.  As 
devices proliferate, so does the diversity of 
software which users use to access the corresponding data.
}
\p{CyberPhysical systems can also be seen in a more holistic way.  
As CyberPhysical networks proliferate, we can envision a 
rise in technologies that merge and integrate data from 
many kinds of devices, from many different vendors.  
This eventuality has already been contemplated, including 
in this volume.  Teixera \i{et. al.}, for example, 
argue that 
\begin{dquote}Overall, the increase in sensors, devices, and appliances, in our homes, has transformed it into a rather complex environment with which to interact. This characteristic cannot be merely addressed by a matching set of device-dependent applications, turning the smart home into a set of isolated interactive artifacts. Hence, there is a strong need to unify this experience, blending this diversity into a unique interactive ecosystem. This can be tackled, to a large extent by the proposal of a unique, integrated, ubiquitous distributed smart home application capable of handling a dynamic set of sensors and devices and providing the different house occupants (e.g., children, teenagers, young adults, and elderly) with natural and simple ways of controlling and accessing information. However, the creation of such application presents a challenge, particularly due to the need to support natural and adaptive forms of interaction beyond a simple home dashboard application.
\end{dquote}
I will use the term \i{hub application} to describe software 
meeting the requirements of what Teixera \i{et. al.} call an 
\q{application capable of handling a dynamic set of 
sensors and devices}. 
}
\p{Hub applications must receive data from 
many kinds of devices.  They must also respond properly to 
data once it is received.  For each kind of device, 
there must then be a corresponding software component,  
part of the hub application, which is specifically 
capable of understanding data generated by \i{that particular} 
device.  For sake of discussion, I will call such 
device-specific software components a \i{hub library}.  
We may assume that hub applications will feature many 
hub libraries, and that implementing hub libraries will 
become an integral step in the process of deploying 
CyberPhysical instruments.  
Hub libraries need to bridge the low-level 
realm of CyberPhysical signals (and the networks that carry them) 
with the high-level realm of software engineering: \GUI{} 
components, data validation, fluid and responsive User Experience, 
and so forth. 
}
\p{Hub applications, in short, serve as central loci organizing 
collections of hub libraries.  In this role they have a significance 
beyond just supplying a User Interface to CyberPhysical data.  
Hub libraries would need to manifest \i{data models}  
conveying technical details about devices; for instance, scientific 
and mathematical details about the proper range and dimensions 
of data fields.  Hub libraries should provide a 
concrete artifact that engineers may consult to obtain information 
about device properties and expected behavior.  
Compared to (as Teixera \i{et. al.} put it) 
\q{a set of isolated interactive artifacts}, I believe 
the centralized architecture of hub applications and hub libraries 
is more conducive to rigorous, concrete representation of CyberPhysical 
devices as technical products.  This centralized focus can  
make CyberPhysical systems more secure and trustworthy \mdash{} 
hub applications may be used for testing and protyping devices and 
their supporting code, even before they are brought to market.            
}
\p{This chapter is not explicitly about hub applications; 
here I will examine coding and code documentation techniques 
which are applicable in many contexts.  However, CyberPhysical 
hubs are a good case study in programming contexts where   
Requirements Engineering is an intrinsic architectural feature.  
I write this 
chapter, then, from the perspective of a programmer 
creating a \q{hub library} for some form of 
CyberPhysical input.  This programmer needs to express in 
code the physical and computational details specific 
to the device's signals; its functionality and 
capabilities.  The hub library should serve 
as a reference point, a proxy for the device itself, 
in that engineers may study the library as an indirect 
way of coming to understand the device.  Given 
these requirements, hub libraries need an especially 
rigorous development methodology, one that emphasizes 
strict documentation and verification of coding requirements.    
} 
\p{I claim, also, that hub libraries are operationally similar 
to code libraries providing access to scientific 
data sets.  In practice, most CyberPhysical devices are 
products of Research and Development cycles that emanate 
from scientific and technological advances.  Research 
data generated during an \RnD{} phase may therefore be 
an originating source for data models which ultimately govern 
the deployed CyberPhysical software.  As a result, code 
libraries which systematically access research data 
may be seen as ancestral versions of hub libraries 
\mdash{} even though hub 
libraries prototypically work with real-time input, 
whereas data sets are curated information spaces that are 
frozen and time and potentially reused in multiple 
research projects.    
}
\p{In essense, libraries for accessing research data sets 
subtract the real-time networking logic from hub 
libraries: their input data comes from static files, not 
from any kind of decentralized or wireless networks.  
Hub libraries actually have two roles: they are low-level 
drivers attuned to network signals and also high-level 
processors transforming raw data into analyzable and 
visualizable representations.  Hub libraries can 
inherit the second, high-level logic from \RnD{} 
data-set libraries.  This means that published data sets, 
and their accompanying code, are an important foundation 
for establishing data models and coding practices that may 
propagate through CyberPhysical systems' subsequent  
deployment phases.          
}
\p{So, although I claimed to write this chapter from the perspective 
of a programming writing a hub library, it is more literally 
accurate to say that I am writing from the perspective 
of a programmer writing dataset applications \mdash{} because 
that \i{is} my perspective in real life.  I contend that 
dataset applications are a reasonable proxy for hypothetical 
hub libraries, so that these perspectives will coincide 
for many practical purposes.  
The demo code for this chapter includes several re-published 
data sets in several technical and CyberPhysical domains 
(bioacoustics, speech samples, and parsed language samples) 
together with \q{dataset applications} to access research 
data and model its properties.  I hope these demonstrations 
serve to illustrate how future CyberPhysical data sets might 
be organized.  I have supplemented the data sets with 
code bases operationalizing many of the theoretical 
paradigms I present in the second half of this chapter.  
For example, the code provides a modest but demonstrative 
scripting platform via a hypergraph-based Intermediate 
Representation based on (what I call) Channel Algebra.  
A few code samples are drawn from the demo and 
published here to illustrate 
some basic patterns in these hypergraph structures; 
interested readers may find that work discussed in much 
greater detail in the documentation for the demo code.   
}
\p{The first two sections in this chapter, however, are 
less theoretical and less code-oriented.  These sections discuss 
hub applications and CyberPhysical systems on a more practical 
level: what are representative examples of  
data structures and coding requirements that hub 
libraries will need to encapsulate?  I will 
then, in the final two sections, turn to 
computer code at a more theoretical level, outlining 
certain representational paradigms, such as 
Directed Hypergraphs, which I believe can yield more 
expressive and comprehensive models of coding structures 
and requirements.  
}
