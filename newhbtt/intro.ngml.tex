\p{It is possible to look at CyberPhysical systems in isolation: there is 
one kind of CyberPhysical \i{device}, a sensor or actuator, that 
generates data and/or can effectuate physical change in its 
surrounding environment.  Potentially there are two or more kinds 
of devices which generate overlapping or interconnected kinds 
of data.  CyberPhysical \i{signals} are then sent to a  
\i{software} point where the input is interpreted and transformed for 
practical use: stored in a database, displayed for human users, 
and/or subject to data mining and analysis.  We live in a world 
where more and more kinds of devices proliferate, as do devices 
themselves.  As a result, there are more and more networks generating 
data, and proportionately more access points for people to see and 
act upon that data.
}
\p{CyberPhysical systems can also be seen in a more holistic way.  
As CyberPhysical networks proliferate, we can envision a 
rise in technologies that merge and integrate data from 
many kinds of devices, from many different vendors.  
This eventuality has already been contemplated, including 
in this volume.  Teixera \i{et. al.}, for example, 
argue that 
\begin{dquote}Overall, the increase in sensors, devices, and appliances, in our homes, has transformed it into a rather complex environment with which to interact. This characteristic cannot be merely addressed by a matching set of device-dependent applications, turning the smart home into a set of isolated interactive artifacts. Hence, there is a strong need to unify this experience, blending this diversity into a unique interactive ecosystem. This can be tackled, to a large extent by the proposal of a unique, integrated, ubiquitous distributed smart home application capable of handling a dynamic set of sensors and devices and providing the different house occupants (e.g., children, teenagers, young adults, and elderly) with natural and simple ways of controlling and accessing information. However, the creation of such application presents a challenge, particularly due to the need to support natural and adaptive forms of interaction beyond a simple home dashboard application.
\end{dquote}
In this chapter, I will refer to an \q{application capable of handling a dynamic set of 
sensors and devices} as a \i{hub application}. 
}
\p{Assuming hub applications become popular, this technology may 
fundamentally change how CyberPhysical devices are designed.  
Alongside \q{isolated} access 
points \mdash{} such as Smart Phone apps, which are 
often created by the same companies as market devices 
themselves \mdash{} hub applications would become an alternative  
recipient of CyberPhysical information.  The total 
network \mdash{} encompassing hub applications, along with all 
devices from which they obtain input \mdash{} would 
integrate variegated technologies, offered by many 
different companies.  Standardized formats would need 
to be engineered \mdash{} not only for the stage of 
sending signals between devices and hubs, but for 
the higher-level project of designing application components 
which can understand and display device data.  The essential 
question at this level is not how to transmit \i{raw} data,
but how CyberPhysical components can transform raw 
data into visual, interactive displays for users' benefit. 
}
\p{Hub applications, for their part, must receive data from 
many kinds of devices, but also respond properly to 
data once it is received.  For each kind of device, 
there must then be a corresponding software component,  
part of the hub application, which is specifically 
capable of understanding data generated by \i{that particular} 
device.  For sake of discussion, I will call such 
device-specific software components a \i{hub library}.  
We may assume that hub applications will feature many 
hub libraries, and that implementing hub libraries will 
become an integral step in the process of deploying 
CyberPhysical instruments.  These hub libraies would 
have requirements beyond just low-level \q{driver} code; 
they would also be responsible for validating input, 
confirming that their associated device is working properly, 
and transforming raw data into usable software artifacts.  
In short, hub libraries need to bridge the low-level 
realm of CyberPhysical signals (and the networks that carry them) 
with the high-level realm of software engineering: \GUI{} 
components, data validation, fluid and responsive User Experience, 
and so forth. 
}
\p{In short, hub \i{applications} create a need for hub \i{libraries}, 
which would then become an intrinsic part of device creation.  
A hub library serves as a reference point and prototype for 
device properties: a well implemented library should document 
the kind of data its corresponding device generates; what are its 
structural or numerical properties; and what are the proper algorithms 
for mapping raw data into usable data structures.  Hub libraries, 
in other words, are manifestations of \i{data models} which 
convey technical details about devices; for instance, scientific 
and mathematical details about the proper range and dimensions 
of data fields.   
}
\p{Here, then, hub applications have a significance which may not 
be obvious to their users.  In addition to providing software-based 
access to CyberPhysical information, hub applications would serve 
as a central reference point for conceptualizing how CyberPhysical 
devices operate.  Hub libraries, in particular, would provide a 
concrete artifact that engineers could consult to obtain information 
about device properties, data models, and expected behavior.  
Compared to \q{a set of isolated interactive artifacts}, I believe 
the centralized architecture of hub applications and hub libraries 
is more conducive to rigorous, concrete representation of CyberPhysical 
devices as technical products.  This centralized focus can also 
make CyberPhysical systems more secure and trustworthy \mdash{} 
hub applications can be used for testing and protyping devices and 
their supporting code, even before devices are brought to market.            
}
\p{This chapter is not explicitly about hub applications; 
here I will examine coding and code documentation techniques 
which are applicable in many contexts.  However, CyberPhysical 
hubs are a good case study in programming contexts where   
Requirements Engineering is an intrinsic architectural feature.  
I write this 
chapter, then, from the perspective of a programmer 
creating a \q{hub library} for some form of 
CyberPhysical input.  This programmer needs to express in 
code the physical and computational details specific 
to the device's signals; its functionality and 
capabilities.  The hub library has to verify data integrity 
\i{and also} to profile the shape of data generated 
by properly functioning devices.  The hub library has to serve 
as a reference point, a proxy for the device itself, 
in that engineers may study the library as an indirect 
way of coming to understand the device.  Given 
these requirements, hub libraries need an especially 
rigorous development methodology, one that emphasizes 
strict documentation and verification of coding requirements.    
} 
\p{The first two sections in this chapter will discuss hub 
applications and CyberPhysical systems on a more practical 
level: what are representative examples of the 
data structures and coding requirements that hub 
libraries will need to encapsulate?  I will 
then, in the final two sections, turn to 
computer code at a more theoretical level, outlining 
certain representational paradigms, such as 
Directed Hypergraphs, which I believe can yield more 
expressive and comprehensive models of coding structures 
and requirements.  
}
